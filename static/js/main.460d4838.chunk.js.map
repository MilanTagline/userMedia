{"version":3,"sources":["camera/styles.js","camera/index.js","hooks/use-user-media.js","hooks/use-card-ratio.js","hooks/use-offsets.js","App.js","index.js"],"names":["flashAnimation","keyframes","Wrapper","styled","div","Container","maxWidth","maxHeight","Canvas","canvas","Video","video","Overlay","Flash","flash","css","Button","button","CAPTURE_OPTIONS","audio","facingMode","Camera","onCapture","onClear","canvasRef","useRef","videoRef","useState","width","height","container","setContainer","isVideoPlaying","setIsVideoPlaying","isCanvasEmpty","setIsCanvasEmpty","isFlashing","setIsFlashing","mediaStream","requestedMedia","setMediaStream","useEffect","a","navigator","mediaDevices","alert","console","log","getUserMedia","stream","getTracks","forEach","track","stop","enableVideoStream","useUserMedia","initialParams","aspectRatio","setAspectRatio","useCallback","useCardRatio","calculateRatio","offsets","vWidth","vHeight","cWidth","cHeight","x","y","setOffsets","Math","round","useOffsets","current","videoWidth","videoHeight","handleCanPlay","play","handleCapture","getContext","drawImage","toBlob","blob","handleClear","clearRect","srcObject","bounds","onResize","contentRect","measureRef","ref","style","hidden","onCanPlay","autoPlay","playsInline","muted","top","left","onAnimationEnd","onClick","App","cardImage","setCardImage","undefined","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.460d4838.chunk.js","sourcesContent":["import styled, { keyframes, css } from \"styled-components\";\n\nconst flashAnimation = keyframes`\n  from {\n    opacity: 0.75;\n  }\n\n  to {\n    opacity: 0;\n  }\n`;\n\nexport const Wrapper = styled.div`\n  display: flex;\n  flex-flow: column;\n  align-items: center;\n  width: 100%;\n`;\n\nexport const Container = styled.div`\n  position: relative;\n  width: 100%;\n  max-width: ${({ maxWidth }) => maxWidth && `${maxWidth}px`};\n  max-height: ${({ maxHeight }) => maxHeight && `${maxHeight}px`};\n  overflow: hidden;\n`;\n\nexport const Canvas = styled.canvas`\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n`;\n\nexport const Video = styled.video`\n  position: absolute;\n\n  &::-webkit-media-controls-play-button {\n    display: none !important;\n    -webkit-appearance: none;\n  }\n`;\n\nexport const Overlay = styled.div`\n  position: absolute;\n  top: 20px;\n  right: 20px;\n  bottom: 20px;\n  left: 20px;\n  box-shadow: 0px 0px 20px 56px rgba(0, 0, 0, 0.6);\n  border: 1px solid #ffffff;\n  border-radius: 10px;\n`;\n\nexport const Flash = styled.div`\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background-color: #ffffff;\n  opacity: 0;\n\n  ${({ flash }) => {\n    if (flash) {\n      return css`\n        animation: ${flashAnimation} 750ms ease-out;\n      `;\n    }\n  }}\n`;\n\nexport const Button = styled.button`\n  width: 75%;\n  min-width: 100px;\n  max-width: 250px;\n  margin-top: 24px;\n  padding: 12px 24px;\n  background: silver;\n`;\n","import React, { useState, useRef } from \"react\";\nimport Measure from \"react-measure\";\nimport { useUserMedia } from \"../hooks/use-user-media\";\nimport { useCardRatio } from \"../hooks/use-card-ratio\";\nimport { useOffsets } from \"../hooks/use-offsets\";\nimport {\n  Video,\n  Canvas,\n  Wrapper,\n  Container,\n  Flash,\n  Overlay,\n  Button\n} from \"./styles\";\n\nconst CAPTURE_OPTIONS = {\n  audio: false,\n  video: { facingMode: \"environment\" }\n};\n\nexport function Camera({ onCapture, onClear }) {\n  const canvasRef = useRef();\n  const videoRef = useRef();\n\n  const [container, setContainer] = useState({ width: 0, height: 0 });\n  const [isVideoPlaying, setIsVideoPlaying] = useState(false);\n  const [isCanvasEmpty, setIsCanvasEmpty] = useState(true);\n  const [isFlashing, setIsFlashing] = useState(false);\n\n  const mediaStream = useUserMedia(CAPTURE_OPTIONS);\n  const [aspectRatio, calculateRatio] = useCardRatio(1.586);\n  const offsets = useOffsets(\n    videoRef.current && videoRef.current.videoWidth,\n    videoRef.current && videoRef.current.videoHeight,\n    container.width,\n    container.height\n  );\n\n  if (mediaStream && videoRef.current && !videoRef.current.srcObject) {\n    videoRef.current.srcObject = mediaStream;\n  }\n\n  function handleResize(contentRect) {\n    setContainer({\n      width: contentRect.bounds.width,\n      height: Math.round(contentRect.bounds.width / aspectRatio)\n    });\n  }\n\n  function handleCanPlay() {\n    calculateRatio(videoRef.current.videoHeight, videoRef.current.videoWidth);\n    setIsVideoPlaying(true);\n    videoRef.current.play();\n  }\n\n  function handleCapture() {\n    const context = canvasRef.current.getContext(\"2d\");\n\n    context.drawImage(\n      videoRef.current,\n      offsets.x,\n      offsets.y,\n      container.width,\n      container.height,\n      0,\n      0,\n      container.width,\n      container.height\n    );\n\n    canvasRef.current.toBlob(blob => onCapture(blob), \"image/jpeg\", 1);\n    setIsCanvasEmpty(false);\n    setIsFlashing(true);\n  }\n\n  function handleClear() {\n    const context = canvasRef.current.getContext(\"2d\");\n    context.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n    setIsCanvasEmpty(true);\n    onClear();\n  }\n\n  if (!mediaStream) {\n    return null;\n  }\n\n  return (\n    <Measure bounds onResize={handleResize}>\n      {({ measureRef }) => (\n        <Wrapper>\n          <Container\n            ref={measureRef}\n            maxHeight={videoRef.current && videoRef.current.videoHeight}\n            maxWidth={videoRef.current && videoRef.current.videoWidth}\n            style={{\n              height: `${container.height}px`\n            }}\n          >\n            <Video\n              ref={videoRef}\n              hidden={!isVideoPlaying}\n              onCanPlay={handleCanPlay}\n              autoPlay\n              playsInline\n              muted\n              style={{\n                top: `-${offsets.y}px`,\n                left: `-${offsets.x}px`\n              }}\n            />\n\n            <Overlay hidden={!isVideoPlaying} />\n\n            <Canvas\n              ref={canvasRef}\n              width={container.width}\n              height={container.height}\n            />\n\n            <Flash\n              flash={isFlashing}\n              onAnimationEnd={() => setIsFlashing(false)}\n            />\n          </Container>\n\n          {isVideoPlaying && (\n            <Button onClick={isCanvasEmpty ? handleCapture : handleClear}>\n              {isCanvasEmpty ? \"Take a picture\" : \"Take another picture\"}\n            </Button>\n          )}\n        </Wrapper>\n      )}\n    </Measure>\n  );\n}\n","import { useState, useEffect } from \"react\";\n\nexport function useUserMedia(requestedMedia) {\n  const [mediaStream, setMediaStream] = useState(null);\n\n  useEffect(() => {\n    async function enableVideoStream() {\n      try {\n        if (!navigator.mediaDevices) {\n          alert(\"no media\")\n          console.log(\"Sorry, getUserMedia is not supported\");\n          return;\n        }\n\n        const stream = await navigator.mediaDevices.getUserMedia(\n          {video : true}\n          // requestedMedia\n        );\n        console.log('srtream :>> ', stream);\n        setMediaStream(stream);\n      } catch (err) {\n        // Handle the error\n      }\n    }\n\n    if (!mediaStream) {\n      enableVideoStream();\n    } else {\n      return function cleanup() {\n        mediaStream.getTracks().forEach(track => {\n          track.stop();\n        });\n      };\n    }\n  }, [mediaStream, requestedMedia]);\n\n  return mediaStream;\n}\n","import { useState, useCallback } from \"react\";\n\n/**\n * Since the camera container resembles a licence card, the height must always be less than the\n * width (regardless of the resolution of the camera). This is achieved by calculating a ratio\n * that is always >= 1 by dividing by the largest dimension.\n **/\nexport function useCardRatio(initialParams) {\n  const [aspectRatio, setAspectRatio] = useState(initialParams);\n\n  const calculateRatio = useCallback((height, width) => {\n    if (height && width) {\n      const isLandscape = height <= width;\n      const ratio = isLandscape ? width / height : height / width;\n\n      setAspectRatio(ratio);\n    }\n  }, []);\n\n  return [aspectRatio, calculateRatio];\n}\n","import { useState, useEffect } from \"react\";\n\n/**\n * In the event that the video (v) is larger than it's parent container (c), calculate offsets\n * to center the container in the middle of the video.\n **/\nexport function useOffsets(vWidth, vHeight, cWidth, cHeight) {\n  const [offsets, setOffsets] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    if (vWidth && vHeight && cWidth && cHeight) {\n      const x = vWidth > cWidth ? Math.round((vWidth - cWidth) / 2) : 0;\n      const y = vHeight > cHeight ? Math.round((vHeight - cHeight) / 2) : 0;\n\n      setOffsets({ x, y });\n    }\n  }, [vWidth, vHeight, cWidth, cHeight]);\n\n  return offsets;\n}\n","import React,{useState,Fragment} from 'react'\nimport { Camera } from \"./camera\";\nimport ValidateForm from './ValidateForm'\n\nconst App = () => {\n\n  const [cardImage, setCardImage] = useState();\n\n  console.log('cardImage :>> ', cardImage);\n\n  return (\n    <Fragment>\n      <Camera\n          onCapture={(blob) => setCardImage(blob)}\n          onClear={() => setCardImage(undefined)}\n        />\n    </Fragment>\n    // <div style={{margin:\"100px\"}}>\n    //   <ValidateForm/>\n    // </div>\n  )\n}\nexport default App\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n\nReactDOM.render(<App />,document.getElementById('root'));\n\n\n"],"sourceRoot":""}